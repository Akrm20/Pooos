<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Sentence Saver with Voice (Recording)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #6e8efb 0%, #a777e3 100%);
            color:#333; line-height:1.5; min-height:100vh; padding:15px;
        }
        .container { max-width:820px; margin:0 auto; padding-bottom:30px; }
        header { text-align:center; padding:18px 10px; color:white; margin-bottom:18px; }
        h1 { font-size:1.6rem; margin-bottom:6px; text-shadow:0 2px 4px rgba(0,0,0,0.2); }
        .subtitle { font-size:0.95rem; opacity:0.95; }
        .card { background:white; border-radius:14px; padding:16px; margin-bottom:18px; box-shadow:0 10px 30px rgba(0,0,0,0.08); }
        h2 { font-size:1.1rem; margin-bottom:12px; color:#5a67d8; display:flex; align-items:center; gap:10px; }
        .field { margin-bottom:12px; }
        input[type="text"], textarea {
            width:100%; padding:12px; border-radius:10px; border:1px solid #e2e8f0; font-size:0.98rem; font-family:inherit;
        }
        textarea { height:90px; resize:none; }
        .button-group { display:flex; gap:10px; flex-wrap:wrap; }
        button {
            padding:12px 16px; border:none; border-radius:10px; font-weight:600; cursor:pointer; display:flex; gap:8px; align-items:center;
        }
        .primary { background:#6e8efb; color:white; }
        .secondary { background:#edf2f7; color:#334155; }
        .danger { background:#fc8181; color:white; }
        .success { background:#68d391; color:white; }
        .record-btn { background:#f6ad55; color:white; min-width:150px; justify-content:center; }
        .small-icon-btn { width:38px; height:38px; border-radius:50%; display:flex; align-items:center; justify-content:center; background:#edf2f7; border:none; cursor:pointer; }
        .sentences-list { max-height:380px; overflow-y:auto; -webkit-overflow-scrolling:touch; margin-top:8px; }
        .sentence-item { padding:12px; border-bottom:1px solid #e2e8f0; display:flex; gap:12px; align-items:flex-start; }
        .sentence-main { flex:1; }
        .sentence-text { font-size:1rem; margin-bottom:6px; }
        .translation-text { color:#4a5568; font-size:0.95rem; margin-bottom:6px; }
        .meta { font-size:0.82rem; color:#94a3b8; display:flex; gap:8px; align-items:center; }
        .actions { display:flex; gap:8px; align-items:center; }
        .empty-state { text-align:center; padding:30px 12px; color:#a0aec0; }
        .stats { display:flex; justify-content:space-between; padding:12px; background:#f7fafc; border-radius:10px; margin-top:14px; font-size:0.9rem; }
        .stat-value { font-size:1.2rem; font-weight:700; color:#6e8efb; }
        .notification { position:fixed; bottom:18px; left:50%; transform:translateX(-50%) translateY(100px); background:#48bb78; color:white; padding:12px 20px; border-radius:10px; opacity:0; z-index:1200; transition:transform .28s, opacity .28s; max-width:90%; text-align:center; }
        .notification.show { transform:translateX(-50%) translateY(0); opacity:1; }
        @media (max-width:480px) {
            .button-group { flex-direction:column; }
            button { width:100%; }
            .record-btn { min-width:auto; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-microphone"></i> Sentence Saver - Recording</h1>
            <p class="subtitle">سجّل صوتك مباشرة من المايك، واحفظ الجملة مع الترجمة</p>
        </header>

        <main>
            <div class="card">
                <h2><i class="fas fa-edit"></i> Add / تسجيل جملة</h2>

                <div class="field">
                    <label for="sentenceInput"><strong>Sentence (English)</strong></label>
                    <textarea id="sentenceInput" placeholder="Type or paste the English sentence here..."></textarea>
                </div>

                <div class="field">
                    <label for="translationInput"><strong>Translation (الترجمة)</strong></label>
                    <input id="translationInput" type="text" placeholder="اكتب الترجمة العربية هنا..." />
                </div>

                <div class="field" style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
                    <button id="recordToggleBtn" class="record-btn">
                        <i class="fas fa-microphone"></i> Start Recording
                    </button>

                    <div id="recordStatus" style="font-size:0.95rem; color:#334155;"></div>

                    <audio id="previewAudio" controls style="display:none; width:100%; margin-top:8px;"></audio>
                </div>

                <div class="button-group" style="margin-top:12px;">
                    <button id="saveBtn" class="primary"><i class="fas fa-save"></i> Save (حفظ)</button>
                    <button id="clearInputBtn" class="secondary"><i class="fas fa-eraser"></i> Clear Input</button>
                </div>
            </div>

            <div class="card">
                <h2><i class="fas fa-list"></i> Saved Sentences <span id="countBadge" style="background:#6e8efb;color:white;font-size:0.85rem;padding:3px 10px;border-radius:20px;margin-left:8px;">0</span></h2>

                <div class="sentences-list" id="sentencesList">
                    <div class="empty-state" id="emptyState">
                        <i class="fas fa-inbox" style="font-size:2.6rem;opacity:.6;"></i>
                        <p>No sentences saved yet. Paste a sentence and record audio to save it.</p>
                    </div>
                </div>

                <div class="button-group" style="margin-top:16px;">
                    <button id="exportBtn" class="success"><i class="fas fa-file-export"></i> Export Text (Export .txt)</button>
                    <button id="clearAllBtn" class="danger"><i class="fas fa-trash-alt"></i> Clear All</button>
                </div>

                <div class="stats">
                    <div>
                        <div class="stat-value" id="totalCount">0</div>
                        <div class="stat-label">Total</div>
                    </div>
                    <div>
                        <div class="stat-value" id="charCount">0</div>
                        <div class="stat-label">Characters</div>
                    </div>
                    <div>
                        <div class="stat-value" id="wordCount">0</div>
                        <div class="stat-label">Words</div>
                    </div>
                </div>
            </div>
        </main>

        <div class="notification" id="notification"><span id="notificationText"></span></div>
    </div>

    <script>
    /*******************************
     * Sentence Saver with Voice
     * - Stores sentence, translation, audio Blob, and date in IndexedDB
     * - Recording uses MediaRecorder (mobile compatible browsers)
     * - Single toggle record button: Start Recording -> Stop Recording -> Play (preview)
     *******************************/

    // Database config
    const DB_NAME = 'SentenceSaverDB';
    const STORE_NAME = 'sentences';
    const DB_VERSION = 2; // bumped version to add audio/translation

    let db;
    let sentences = [];

    // Recording state
    let mediaRecorder = null;
    let recordedChunks = [];
    let currentAudioBlob = null; // Blob of last recording (not yet saved)
    let isRecording = false;
    let isPlaybackMode = false;

    // DOM
    const sentenceInput = document.getElementById('sentenceInput');
    const translationInput = document.getElementById('translationInput');
    const recordToggleBtn = document.getElementById('recordToggleBtn');
    const recordStatus = document.getElementById('recordStatus');
    const previewAudio = document.getElementById('previewAudio');
    const saveBtn = document.getElementById('saveBtn');
    const clearInputBtn = document.getElementById('clearInputBtn');
    const exportBtn = document.getElementById('exportBtn');
    const clearAllBtn = document.getElementById('clearAllBtn');
    const sentencesList = document.getElementById('sentencesList');
    const emptyState = document.getElementById('emptyState');
    const notification = document.getElementById('notification');
    const notificationText = document.getElementById('notificationText');
    const countBadge = document.getElementById('countBadge');
    const totalCountElement = document.getElementById('totalCount');
    const charCountElement = document.getElementById('charCount');
    const wordCountElement = document.getElementById('wordCount');

    document.addEventListener('DOMContentLoaded', () => {
        initDB();
        setupEventListeners();
        // sample placeholder
        setTimeout(() => {
            if (!sentenceInput.value) {
                sentenceInput.value = "This is a sample sentence. Type your sentence here.";
                translationInput.value = "هذه جملة تجريبية.";
            }
        }, 400);
    });

    function setupEventListeners() {
        recordToggleBtn.addEventListener('click', handleRecordToggle);
        saveBtn.addEventListener('click', saveSentenceWithAudio);
        clearInputBtn.addEventListener('click', clearInputFields);
        exportBtn.addEventListener('click', exportToFile);
        clearAllBtn.addEventListener('click', clearAllSentences);

        sentenceInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                saveSentenceWithAudio();
            }
        });
    }

    // Initialize IndexedDB
    function initDB() {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onerror = (event) => {
            console.error('DB error', event.target.error);
            showNotification('Failed to initialize database', 'error');
        };

        request.onupgradeneeded = (event) => {
            db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                const store = db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                store.createIndex('date', 'date', { unique: false });
            } else {
                // object store exists; if migrating, it's fine — we'll add properties dynamically per record
            }
        };

        request.onsuccess = (event) => {
            db = event.target.result;
            loadSentences();
        };
    }

    // Load all sentences
    function loadSentences() {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const index = store.index('date');
        const request = index.getAll();

        request.onsuccess = (event) => {
            sentences = event.target.result || [];
            renderSentences();
            updateStats();
        };

        request.onerror = (event) => {
            console.error('Error loading sentences', event.target.error);
            showNotification('Failed to load saved sentences', 'error');
        };
    }

    // Handle record toggle button (Start -> Stop -> Play preview)
    async function handleRecordToggle() {
        if (!isRecording && !isPlaybackMode) {
            // Start recording
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showNotification('Microphone not supported in this browser', 'error');
                return;
            }
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                recordedChunks = [];
                mediaRecorder = new MediaRecorder(stream);
                mediaRecorder.ondataavailable = (e) => {
                    if (e.data && e.data.size > 0) recordedChunks.push(e.data);
                };
                mediaRecorder.onstop = () => {
                    currentAudioBlob = new Blob(recordedChunks, { type: 'audio/webm' });
                    preparePreview(currentAudioBlob);
                    // Stop all tracks to release mic
                    stream.getTracks().forEach(t => t.stop());
                };
                mediaRecorder.start();
                isRecording = true;
                updateRecordButton();
                recordStatus.textContent = 'Recording...';
            } catch (err) {
                console.error('getUserMedia error', err);
                showNotification('Could not access microphone. Allow microphone permission.', 'error');
            }
        } else if (isRecording) {
            // Stop recording
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            isRecording = false;
            isPlaybackMode = true;
            updateRecordButton();
            recordStatus.textContent = 'Recording stopped — preview available';
        } else if (!isRecording && isPlaybackMode) {
            // Play preview (toggle play/pause on previewAudio)
            if (previewAudio.src) {
                if (previewAudio.paused) {
                    previewAudio.play();
                } else {
                    previewAudio.pause();
                }
            }
        }
    }

    function updateRecordButton() {
        if (isRecording) {
            recordToggleBtn.innerHTML = '<i class="fas fa-stop"></i> Stop Recording';
            recordToggleBtn.style.background = '#f56565';
        } else if (isPlaybackMode) {
            recordToggleBtn.innerHTML = '<i class="fas fa-play"></i> Play Preview';
            recordToggleBtn.style.background = '#48bb78';
        } else {
            recordToggleBtn.innerHTML = '<i class="fas fa-microphone"></i> Start Recording';
            recordToggleBtn.style.background = '';
        }
    }

    function preparePreview(blob) {
        if (!blob) return;
        const url = URL.createObjectURL(blob);
        previewAudio.src = url;
        previewAudio.style.display = 'block';
        previewAudio.controls = true;
    }

    function clearPreview() {
        previewAudio.pause();
        previewAudio.src = '';
        previewAudio.style.display = 'none';
        if (previewAudio.src) URL.revokeObjectURL(previewAudio.src);
        currentAudioBlob = null;
        isPlaybackMode = false;
        updateRecordButton();
        recordStatus.textContent = '';
    }

    // Save sentence + translation + audio blob into IndexedDB
    function saveSentenceWithAudio() {
        const text = sentenceInput.value.trim();
        const translation = translationInput.value.trim();

        if (!text) {
            showNotification('Please enter a sentence before saving', 'warning');
            sentenceInput.focus();
            return;
        }

        // Build object
        const obj = {
            text,
            translation: translation || '',
            date: new Date().toISOString(),
            audio: currentAudioBlob || null // may be null if user didn't record
        };

        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.add(obj);

        request.onsuccess = () => {
            showNotification('Saved sentence successfully', 'success');
            clearInputFields();
            loadSentences();
            clearPreview();
        };

        request.onerror = (e) => {
            console.error('Save error', e);
            showNotification('Failed to save sentence', 'error');
        };
    }

    function clearInputFields() {
        sentenceInput.value = '';
        translationInput.value = '';
        clearPreview();
        sentenceInput.focus();
        showNotification('Input cleared', 'info');
    }

    // Delete one sentence by id
    function deleteSentence(id) {
        if (!confirm('Are you sure you want to delete this sentence?')) return;
        const tx = db.transaction([STORE_NAME], 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        const req = store.delete(id);
        req.onsuccess = () => {
            showNotification('Deleted', 'success');
            loadSentences();
        };
        req.onerror = (e) => {
            console.error('Delete error', e);
            showNotification('Failed to delete', 'error');
        };
    }

    // Copy to clipboard
    function copyToClipboard(text) {
        navigator.clipboard.writeText(text).then(() => {
            showNotification('Copied to clipboard', 'success');
        }).catch(err => {
            console.error('Copy failed', err);
            showNotification('Failed to copy', 'error');
        });
    }

    // Export sentences to text file (includes translations)
    function exportToFile() {
        if (sentences.length === 0) {
            showNotification('No sentences to export', 'warning');
            return;
        }
        let exportText = `=== Exported Sentences (${sentences.length}) ===\n\n`;
        sentences.forEach((s, i) => {
            const dateStr = new Date(s.date).toLocaleString();
            exportText += `${i+1}. ${s.text}\n   Translation: ${s.translation || '-'}\n   Saved: ${dateStr}\n\n`;
        });
        exportText += `Exported on: ${new Date().toLocaleString()}\nTotal: ${sentences.length}\n`;
        const blob = new Blob([exportText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `sentences_${new Date().toISOString().slice(0,10)}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showNotification('Exported to .txt file', 'success');
    }

    // Clear all sentences
    function clearAllSentences() {
        if (sentences.length === 0) {
            showNotification('No sentences to clear', 'info');
            return;
        }
        if (!confirm(`Are you sure you want to delete all ${sentences.length} sentences?`)) return;
        const tx = db.transaction([STORE_NAME], 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        const req = store.clear();
        req.onsuccess = () => {
            showNotification('All sentences cleared', 'success');
            loadSentences();
        };
        req.onerror = (e) => {
            console.error('Clear all error', e);
            showNotification('Failed to clear all', 'error');
        };
    }

    // Render sentences list
    function renderSentences() {
        sentencesList.innerHTML = '';
        if (!sentences || sentences.length === 0) {
            sentencesList.appendChild(emptyState);
            emptyState.style.display = 'block';
            countBadge.textContent = '0';
            totalCountElement.textContent = '0';
            charCountElement.textContent = '0';
            wordCountElement.textContent = '0';
            return;
        }
        emptyState.style.display = 'none';
        countBadge.textContent = sentences.length;

        // Sort newest first
        const sorted = [...sentences].sort((a,b) => new Date(b.date) - new Date(a.date));
        sorted.forEach(s => {
            const item = document.createElement('div');
            item.className = 'sentence-item';

            const main = document.createElement('div');
            main.className = 'sentence-main';

            const txtDiv = document.createElement('div');
            txtDiv.className = 'sentence-text';
            txtDiv.textContent = s.text;

            const transDiv = document.createElement('div');
            transDiv.className = 'translation-text';
            transDiv.textContent = s.translation || '(no translation)';

            const meta = document.createElement('div');
            meta.className = 'meta';
            const date = new Date(s.date);
            meta.innerHTML = `<i class="far fa-clock"></i> ${date.toLocaleDateString()} ${date.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}`;

            main.appendChild(txtDiv);
            main.appendChild(transDiv);
            main.appendChild(meta);

            const actions = document.createElement('div');
            actions.className = 'actions';

            // Play button (if audio exists)
            const playBtn = document.createElement('button');
            playBtn.className = 'small-icon-btn';
            playBtn.title = 'Play audio';
            playBtn.innerHTML = '<i class="fas fa-play"></i>';

            if (s.audio) {
                playBtn.addEventListener('click', () => {
                    // create object URL and play in temporary audio element
                    const audioURL = URL.createObjectURL(s.audio);
                    const a = new Audio(audioURL);
                    a.play();
                    // revoke after ended
                    a.onended = () => URL.revokeObjectURL(audioURL);
                });
            } else {
                playBtn.title = 'No audio recorded';
                playBtn.style.opacity = '0.5';
                playBtn.disabled = true;
            }

            // Copy button
            const copyBtn = document.createElement('button');
            copyBtn.className = 'small-icon-btn';
            copyBtn.title = 'Copy sentence';
            copyBtn.innerHTML = '<i class="fas fa-copy"></i>';
            copyBtn.addEventListener('click', () => copyToClipboard(s.text));

            // Delete button
            const delBtn = document.createElement('button');
            delBtn.className = 'small-icon-btn';
            delBtn.title = 'Delete';
            delBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
            delBtn.addEventListener('click', () => deleteSentence(s.id));

            // Download audio button (if audio exists)
            const dlBtn = document.createElement('button');
            dlBtn.className = 'small-icon-btn';
            dlBtn.title = 'Download audio';
            dlBtn.innerHTML = '<i class="fas fa-download"></i>';
            if (s.audio) {
                dlBtn.addEventListener('click', () => {
                    const url = URL.createObjectURL(s.audio);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `sentence_audio_${s.id}.webm`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                });
            } else {
                dlBtn.style.opacity = '0.5';
                dlBtn.disabled = true;
            }

            actions.appendChild(playBtn);
            actions.appendChild(dlBtn);
            actions.appendChild(copyBtn);
            actions.appendChild(delBtn);

            item.appendChild(main);
            item.appendChild(actions);
            sentencesList.appendChild(item);
        });

        updateStats();
    }

    // Update statistics
    function updateStats() {
        totalCountElement.textContent = sentences.length;
        let totalChars = 0;
        let totalWords = 0;
        sentences.forEach(s => {
            totalChars += (s.text || '').length;
            const words = (s.text || '').split(/\s+/).filter(w => w.length>0);
            totalWords += words.length;
        });
        charCountElement.textContent = totalChars.toLocaleString();
        wordCountElement.textContent = totalWords.toLocaleString();
    }

    // Show notification
    function showNotification(msg, type='info') {
        const colors = { success:'#48bb78', error:'#f56565', warning:'#ed8936', info:'#4299e1' };
        notification.style.backgroundColor = colors[type] || colors.info;
        notificationText.textContent = msg;
        notification.classList.add('show');
        setTimeout(() => notification.classList.remove('show'), 3000);
    }

    // --- When DB changes: load all again (helper) ---
    // Because audio is stored as Blob we must ensure when fetching they remain Blobs.
    // indexedDB returns Blobs correctly.

    // Load on DB changes: we're already loading on success of add/delete/clear.

    // End of script
    </script>
</body>
</html>